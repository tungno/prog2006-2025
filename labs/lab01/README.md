# Lab 01

* Date (soft): Friday, 14th of February
* Date (hard): Friday, 28th of February
* Score: 5
* ChatGPT: **use only** for explanations. Do not use to generate code.
* Co-pilot: **do not use**
* Coding: code it all yourself, using Solidy help guide
* Resources:
   * Solidity - https://docs.soliditylang.org/en/latest/
   * Solidity resources - https://docs.soliditylang.org/en/latest/resources.html
   * Remix project - https://remix-project.org/?lang=en
   * Remix IDE - https://remix.ethereum.org/


# Objectives

* Basic syntax for Solidity
   * basic types
   * function declarations and definitions
   * smart-contract structure
   * smart-contract deployment
* Solidity projects
   * Basic structure of Solidity project files as generated by `remix`
   * Basic tools: `remix` and `remix-ide`


# Instructions

## Task 1: Hello Name

Write the simplest program in Solidity that emits `hello` event when `hello` function is called with a string parameter. 
The event should contain the parameter passed to the `hello` function.
Deploy it, and test it with Remix.
Check how much gas calling the `hello` function consumes.

* Points: 1 point


## Task 2: Rock Paper Scissors

* Paper (P) beats Rock (R)
* Rock (R) beats Scissors (S)
* Scissors (S) beats Paper (P)

Write a smart contract in Solidity that implements a simple Rock-Paper-Scissors game. Two participants, anonymously, can engage, and play it. The winner take the stake in the game. The game should be fair, and the contract should not be able to cheat.

The contract should emit events for each game played, and the winner should be able to withdraw the stake.
The contract can, but does not have to be able to handle multiple games at the same time. A two player game is enough as long as it can be played multiple times.
The play is always only between two players - no multi-player games are allowed.

The contract should have the following functions:
* `play` - to play the game. The function should take a hashed version of the `Vote` (P, R, or S) as a parameter. The function should emit an event with the `msg.sender` and the `Vote` hashed.
* `reveal` - to reveal the vote. The function should take the `Vote` (P, R, or S) as a parameter, and a salt, that was used to salt the vote. The function should emit an event with the `msg.sender` and the `Vote` in plain text version.
* `withdraw` - to withdraw the stake. The function should emit an event with the `msg.sender` and the amount withdrawn. The function should only allow withdrawal, if the game has not ended properly and the winner has not been determined. For example because the second player has not revealed his vote.
* Only two players can play the game at the same time. The contract should not allow more than two players to play the game at the same time.
* The contract should not allow the same player to play the game twice at the same time with oneself.
* The contract should enforce timeout to reveal the vote. If the second player does not reveal the vote within a certain time, the first player should be able to withdraw the stake entire stake (for both players).


Considerations:
* Everything, including all method calls into contracts, are public. This means, the `vote` function should only take a hashed version of a `Vote`, that is, `P`, `R`, or `S`.
* Use one of the standard hash functions built-in Solidity to hash the vote. For example: `keccak256(abi.encodePacked(vote, salt))`.
* Make sure a proper amount of stake is used when players play the game (it has to be more than minimal threshold, non zero, and must be the same for both players).
* Enforce the second player to match the first player stake.
* Make sure the contract is fair, and the contract cannot cheat.
* Test it with Remix.
* Check how much gas it costs two players to play the game if no unusual protocol violations happen.
* Handle **ALL** edge cases and possible protocol violations. Spend some of your time in DESIGN stage. Do not jump to coding right away.
* Points: 4 points


